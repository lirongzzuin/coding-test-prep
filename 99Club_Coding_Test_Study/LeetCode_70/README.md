## 🧗‍♂️ 70. Climbing Stairs (LeetCode)

### 📌 문제 설명

계단을 오르기 위해 한 번에 1계단 또는 2계단씩 이동할 수 있다고 할 때, 정상에 도달하는 서로 다른 방법의 수를 구하는 문제다. 총 `n`개의 계단이 주어지며, 가능한 경로의 개수를 반환한다.

---

### 📥 입력 조건

- `n`: 계단의 개수 (1 <= n <= 45)

---

### 📤 출력 조건

- 정상까지 도달할 수 있는 **서로 다른 방법의 수**를 정수로 반환한다.

---

### 💡 예제

#### 입력: `n = 2`  
출력: `2`  
가능한 방법:
- 1 + 1
- 2

#### 입력: `n = 3`  
출력: `3`  
가능한 방법:
- 1 + 1 + 1
- 1 + 2
- 2 + 1

---

### 🧠 풀이 흐름

이 문제는 전형적인 **피보나치 수열** 구조를 따른다.  

정상에 도달하는 방법의 수는 다음과 같은 점화식으로 표현된다:

```
f(n) = f(n-1) + f(n-2)
```

- 마지막 계단을 1칸 올라온 경우 → `f(n-1)`
- 마지막 계단을 2칸 올라온 경우 → `f(n-2)`

초기 조건:
- `f(1) = 1`
- `f(2) = 2`

이 점화식을 바탕으로 반복문을 사용해 n까지 계산하면 된다.

---

### 💻 코드 구현 (Python)

```python
class Solution(object):
    def climbStairs(self, n):
        if n == 1:
            return 1
        if n == 2:
            return 2

        a, b = 1, 2
        for _ in range(3, n + 1):
            a, b = b, a + b

        return b
```

---

### 📊 시간 및 공간 복잡도

- 시간 복잡도: O(n)
- 공간 복잡도: O(1)

---

### ✏️ 정리

이 문제는 **동적 계획법(DP)**을 훈련하기 좋은 입문 문제다.  
핵심은 피보나치 수열과 같은 점화식을 떠올릴 수 있는지, 그리고 최소한의 상태만 유지하면서 공간 효율성을 고려하는지다.  

점화식 패턴은 계단, 타일 채우기, 동전 교환 등 다양한 문제에 응용될 수 있다.

---

### ✅ 기억할 점

- `f(n) = f(n-1) + f(n-2)` 형태의 점화식을 익숙하게 다뤄야 한다
- 상태 저장은 이전 두 개만 유지해도 충분하다 → 공간 최적화
- 계단 문제는 다양한 변형이 가능하므로 풀이 패턴을 기억해두면 유용하다